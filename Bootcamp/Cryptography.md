## 1. Sum-O-Primes

**Description:**
We have so much faith in RSA we give you not just the product of the primes, but their sum as well!
We're given output.txt and gen.py with a hint: `I love squares :)`

## Solution
 Given
```
n = p * q

x = p + q

c = FLAG^e mod n

e = 65537
```

We can use quadratic eqns to solve using x and n (x and n is given in hex, so convert to integer)
**Code**
```
from Crypto.Util.number import long_to_bytes
from math import isqrt, lcm
from sympy import isprime
from gmpy2 import invert

x = int("1429cf99b5dd5dde9f016095be650d5b0a9a73e648aa72324cb8eb05bd14c1b913539a97f5417474f6014de830ad6dee028dd8908e593b1e99c4cc88f400127214036e71112292e58a2ccffc48f57524aee90f9858d935c7a86297a90c7fe48b80f6c4e8df9eaae501ef40da7984502457255fbc8a9e1574ec6ba210be134f192", 16)

n = int("64fc90f5ca6db24f7bfc6419de407596d29a9ecda526101b8d0eff2181e9b8ed1538a1cbabe4dfc5bcd899976e7739f8b448815b50db36a994c5b1df97981d562c663113fc5ee84f3206aecd18248fb4e9bddf205c8119e8437f7d6522e63d05bc357ae4969a4b3000b8226f8d142c23c4e38cdb0c385bf9564e8a115e4c52b7a2e3a9073a5d99d7bec3bca6452cf0c1b8d8b6b123cc6a6980cf14088d6a2bbb5ed36b85cb0003e535bd16d79ad54ff5b26e62f57de074654493d3a26a149786d5fbf61b42c9305092eb018aa3db3cb18b24f188ae520bd18acf9ffced09a2ba302a520f6e2bfd8eea9adc01eb8ee941181694a3ab493e1aa53fbbbf2851a591", 16)

c = int("56ed81bbc149701110f0a15e2e6078ab926d74ee2c11b804ae4fad4333a25c247f38bb74867922438d10ce529b75f5ee5e29ce71d6f704cc0644f7e78d60a2af8921fbc49326280e3f0c00f2769e837363cbb05dc3f30bda8fdc94111fb025008eae562ae57029d5cfde6bdd09893a738187578d22f82a5f8769f093681662329f05b262c2054f91696a24f631ba8132f3d92ae7758c91fa9b5657e4944c5d5f93afb4af68908d004ae5f97071bcaceb7d0034297eeb897f972b44b0d7def52f46ee45d386a5e24ed613bf7e5177c6e10f69a3d3de0f0c30de0b15d360ee81da3d277a4acf47b6df389c24615884b692e604eba711fc28c34bc56227b8455705", 16)

# Step 1: Compute discriminant
discriminant = x * x - 4 * n
s = isqrt(discriminant)

assert s * s == discriminant, "Not a perfect square"

# Step 2: Recover p and q
p = (x + s) // 2
q = (x - s) // 2

assert p * q == n
assert isprime(p) and isprime(q)

# Step 3: Compute private key
phi = lcm(p - 1, q - 1)
e = 65537
d = invert(e, phi)

# Step 4: Decrypt
m = pow(c, d, n)
flag = long_to_bytes(m)

print(flag.decode())
```

--- 
## 2. Squared Eyes

**Description:**
It was taking forever to get a 2048 bit prime, so I just generated one and used it twice.

## Solution
The same 2048-bit prime was used twice when generating the key. That means instead of n = p * q, we have n = p * p (i.e., n = p^2)
phi(n) = (p - 1)(q - 1)
But here, since p = q, we get:

phi(n) = phi(p^2) = p * (p - 1)
To solve the challenge, we:

Take the square root of n to get p

`phi = p * (p - 1)`

 `d = e ^ -1 % [(p-1) * (q-1)]`

`m = c^d % n`

Convert m to bytes to get the flag

I got m=912327745903138317426723037632596080882852291533603076406890007888287805926165236318117298828527463941218685 when I ran the script initially, so I converted the integer into bytes by
`plaintext = long_to_bytes(m)`
`print(m)`

**Code:**
```
from Crypto.Util.number import long_to_bytes, inverse, isPrime
from gmpy2 import iroot

n = 535860808044009550029177135708168016201451343147313565371014459027743491739422885443084705720731409713775527993719682583669164873806842043288439828071789970694759080842162253955259590552283047728782812946845160334801782088068154453021936721710269050985805054692096738777321796153384024897615594493453068138341203673749514094546000253631902991617197847584519694152122765406982133526594928685232381934742152195861380221224370858128736975959176861651044370378539093990198336298572944512738570839396588590096813217791191895941380464803377602779240663133834952329316862399581950590588006371221334128215409197603236942597674756728212232134056562716399155080108881105952768189193728827484667349378091100068224404684701674782399200373192433062767622841264055426035349769018117299620554803902490432339600566432246795818167460916180647394169157647245603555692735630862148715428791242764799469896924753470539857080767170052783918273180304835318388177089674231640910337743789750979216202573226794240332797892868276309400253925932223895530714169648116569013581643192341931800785254715083294526325980247219218364118877864892068185905587410977152737936310734712276956663192182487672474651103240004173381041237906849437490609652395748868434296753449
e = 65537
c = 222502885974182429500948389840563415291534726891354573907329512556439632810921927905220486727807436668035929302442754225952786602492250448020341217733646472982286222338860566076161977786095675944552232391481278782019346283900959677167026636830252067048759720251671811058647569724495547940966885025629807079171218371644528053562232396674283745310132242492367274184667845174514466834132589971388067076980563188513333661165819462428837210575342101036356974189393390097403614434491507672459254969638032776897417674577487775755539964915035731988499983726435005007850876000232292458554577437739427313453671492956668188219600633325930981748162455965093222648173134777571527681591366164711307355510889316052064146089646772869610726671696699221157985834325663661400034831442431209123478778078255846830522226390964119818784903330200488705212765569163495571851459355520398928214206285080883954881888668509262455490889283862560453598662919522224935145694435885396500780651530829377030371611921181207362217397805303962112100190783763061909945889717878397740711340114311597934724670601992737526668932871436226135393872881664511222789565256059138002651403875484920711316522536260604255269532161594824301047729082877262812899724246757871448545439896

p, exact = iroot(n, 2)
assert exact and isPrime(p)
phi = p * (p - 1)
d = inverse(e, phi)
m = pow(c, d, n)

# integer --> bytes
plaintext = long_to_bytes(m)
print(m)
```

---


  # 3. miniRSA

**Flag:** `picoCTF{n33d_a_lArg3r_e_606ce004}`


- We're given the following values of N, e (public key), c (ciphertext):
```
 N: 29331922499794985782735976045591164936683059380558950386560160105740343201513369939006307531165922708949619162698623675349030430859547825708994708321803705309459438099340427770580064400911431856656901982789948285309956111848686906152664473350940486507451771223435835260168971210087470894448460745593956840586530527915802541450092946574694809584880896601317519794442862977471129319781313161842056501715040555964011899589002863730868679527184420789010551475067862907739054966183120621407246398518098981106431219207697870293412176440482900183550467375190239898455201170831410460483829448603477361305838743852756938687673
  e: 3

ciphertext (c): 2205316413931134031074603746928247799030155221252519872649649212867614751848436763801274360463406171277838056821437115883619169702963504606017565783537203207707757768473109845162808575425972525116337319108047893250549462147185741761825125
```
- I used dcode.fr to get the flag

![image](https://github.com/user-attachments/assets/a92addc4-1560-4abc-be1e-8e3d881b498b)
